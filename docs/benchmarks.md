---
outline: deep
---

# Benchmarks

This page details the benchmarks used to compare EliCS with other ECS
libraries - [bitecs](https://github.com/NateTheGreatt/bitECS), [koota](https://github.com/pmndrs/koota), [becsy](https://lastolivegames.github.io/becsy/) and [ecsy](https://ecsyjs.github.io/ecsy/). The suite runs several scenarios derived from the [noctjs/ecs-benchmark](https://github.com/noctjs/ecs-benchmark) tests.

Each scenario is executed 25 times and the average time is reported to reduce
variance between runs. The following results were generated by running the
benchmark suite. To run the benchmarks yourself, clone the repository and:

```bash
npm install
npm run bench
```

This command builds the library and runs the benchmark suite in the
[`benchmarks`](https://github.com/elixr-games/elics/tree/main/benchmarks) folder. The results will be output to the console.

<!-- benchmark-start -->

## Packed Iteration (5 queries)

Tests optimal-case iteration performance with 1,000 entities each containing components A–E. Five separate systems iterate through dense, homogeneous entity populations, doubling component values. Simulates high-performance scenarios like physics calculations where all entities share identical component layouts. Stresses query iteration speed, component data access patterns, and memory bandwidth utilization with tightly packed archetype storage. Benchmark results:

- `EliCS `: █████████ **7.87 ms**
- `Bitecs`: ███████████ 9.33 ms
- `Koota `: █████████████████ 14.34 ms
- `Becsy `: █████████████████ 14.12 ms
- `Ecsy  `: ████████████████████ 16.05 ms

## Simple Iteration

Evaluates heterogeneous entity processing with 4,000 entities distributed across multiple component combinations (A+B, C+D, C+E, etc.). Three systems perform value swapping between different component pairs, testing the ECS's ability to efficiently handle overlapping queries on diverse entity archetypes. Simulates typical game scenarios where different entity types require different processing systems, stressing archetype diversity handling and query filtering efficiency. Benchmark results:

- `EliCS `: ███████ **9.72 ms**
- `Bitecs`: ███████ 9.81 ms
- `Koota `: ████████████████ 20.76 ms
- `Becsy `: ███████████████ 19.64 ms
- `Ecsy  `: ████████████████████ 24.75 ms

## Fragmented Iteration

Challenges sparse data handling with 26 different component types (A–Z) where only 100 entities exist per archetype, plus a shared Data component across all entities. Two systems process the sparse entity populations, testing fragmented memory access and archetype management. Simulates complex games with many specialized entity types (items, NPCs, effects, UI elements) where entity populations are spread thin across numerous archetypes, stressing cache efficiency and memory layout optimization. Benchmark results:

- `EliCS `: █████████ **6.56 ms**
- `Bitecs`: ████████████ 8.72 ms
- `Koota `: ███████████████████ 12.92 ms
- `Becsy `: ████████████████████ 13.46 ms
- `Ecsy  `: █████████████████ 11.71 ms

## Fragmented Iteration (256 comps)

Like Fragmented Iteration but with 256 distinct component types and a high-index query (Comp255). Stresses multiword bitmasks and query matching across 8 words while keeping sparse archetypes (100 entities per component). Useful to compare scaling beyond 32 components across engines. Benchmark results:

- `EliCS `: ███ **26.42 ms**
- `Bitecs`: ████ 28.87 ms
- `Koota `: ██████████ 73.84 ms
- `Becsy `: ████ 33.55 ms
- `Ecsy  `: ████████████████████ 136.78 ms

## Value Filter (manual, all ops)

Measures the cost of manually filtering component values during iteration across engines. Uses a single numeric component on ~5k entities with values patterned as i % 10, and runs all operators (eq, ne, lt, le, gt, ge, in, nin) each iteration. Compares raw iteration + value access + predicate evaluation performance without engine-specific predicate features. Benchmark results:

- `EliCS `: ████████████ **12.74 ms**
- `Bitecs`: ████████████ 13.10 ms
- `Koota `: █████████████████ 17.99 ms
- `Becsy `: ████████████████████ 20.33 ms
- `Ecsy  `: ██████████████████ 18.47 ms

## Entity Cycle

Benchmarks dynamic entity lifecycle management by repeatedly creating and destroying entities. Starting with 1,000 entities containing component A, each iteration spawns new entities with component B for every A entity, then destroys all B entities. Tests entity creation/destruction performance, memory pool efficiency, and query invalidation overhead. Simulates high-frequency spawning scenarios like bullet systems, particle effects, or temporary game objects, stressing memory allocation/deallocation and archetype table management. Benchmark results:

- `EliCS `: ███ **24.99 ms**
- `Bitecs`: █████ 37.14 ms
- `Koota `: █████████████ 100.05 ms
- `Becsy `: ███ 28.58 ms
- `Ecsy  `: ████████████████████ 143.81 ms

## Add / Remove

Tests component mutation performance through rapid archetype transitions. Starting with 1,000 entities containing component A, the system continuously adds component B to A entities, then removes B from entities that have both A and B. Simulates dynamic state changes like status effects, equipment modifications, or temporary buffs where entities frequently migrate between archetypes. Stresses component addition/removal efficiency, archetype migration performance, and query membership update overhead. Benchmark results:

- `EliCS `: █████ **17.19 ms**
- `Bitecs`: ████████ 25.25 ms
- `Koota `: ████████████████ 47.09 ms
- `Becsy `: ██████ 19.05 ms
- `Ecsy  `: ████████████████████ 58.53 ms
<!-- benchmark-end -->
